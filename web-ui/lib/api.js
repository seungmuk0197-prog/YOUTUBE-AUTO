/**
 * [web-ui] API wrapper for YouTube Auto Studio
 * 경로: web-ui/lib/api.js — 즐겨찾기(toggleProjectPin), 보관(archiveProject/batchArchiveProjects) 등 여기서 호출.
 * Backend: NEXT_PUBLIC_API_BASE_URL 또는 rewrite /api → http://127.0.0.1:5000/api
 */

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000/api';
/** API 서버 오리진 (previewImageUrl이 /api/... 형태일 때 이미지 src에 사용) */
export const API_ORIGIN = API_BASE.replace(/\/api\/?$/, '');

// 디버그 헤더 생성 유틸
function generateRequestId() {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function createDebugHeaders(projectId = null) {
  const headers = {
    'Content-Type': 'application/json',
    'X-Client': 'web-ui',
    'X-Request-Id': generateRequestId(),
  };
  if (projectId) {
    headers['X-Project-Id'] = projectId;
  }
  return headers;
}

// Mock data for development
const MOCK_PROJECTS = [
  {
    id: 'p_20260210_150409_740e',
    name: '주식 투자 설명',
    topic: 'finance',
    created_at: new Date(Date.now() - 86400000).toISOString(),
    updated_at: new Date().toISOString(),
    scenes: [
      {
        id: '781871bd-2fb0-4272-9134-71bce0c659e8',
        text: '안녕하세요. 이 영상은 AI가 자동으로 생성했습니다.',
        narration_ko: '안녕하세요. 이 영상은 AI가 자동으로 생성했습니다.',
        narration_en: 'Hello. This video was automatically generated by AI.',
        image_path: 'assets/images/image_1.jpg',
        audio_path: 'assets/audio/audio_1.mp3',
        durationSec: 5.5
      }
    ],
    settings: {
      tts: {
        voice: 'ko-KR-SunHiNeural',
        audio_paths: ['assets/audio/audio_1.mp3']
      },
      subtitles: {
        enabled: false
      },
      thumbnail: {
        title: 'YouTube Auto Studio',
        bg_color: '#667eea',
        path: 'assets/thumbnails/thumb_1.jpg'
      },
      bgm: {
        enabled: false,
        volume: 0.5
      }
    },
    rendered: false
  },
  {
    id: 'p_20260211_084522_abc1',
    name: '기술 트렌드 리뷰',
    topic: 'technology',
    created_at: new Date(Date.now() - 3600000).toISOString(),
    updated_at: new Date().toISOString(),
    scenes: [],
    settings: {
      tts: { voice: 'en-US-AriaNeural', audio_paths: [] },
      subtitles: { enabled: false },
      thumbnail: { title: '', bg_color: '#667eea', path: '' },
      bgm: { enabled: false, volume: 0.5 }
    },
    rendered: false
  }
];

/**
 * Fetch projects list
 */
export async function fetchProjects(status = 'active') {
  try {
    // status 파라미터 추가: 'active', 'archived', 'all'
    const url = status === 'all' 
      ? `${API_BASE}/projects?status=all`
      : `${API_BASE}/projects?status=${status}`;
    
    const headers = createDebugHeaders();
    console.log('[API] GET', url, { headers });
    
    const response = await fetch(url, { headers });
    if (response.ok) {
      const data = await response.json();
      console.log('[API] GET Response:', { status, count: data.projects?.length || 0 });
      return data.projects || [];
    }
    return MOCK_PROJECTS;
  } catch (error) {
    console.warn('[API] Failed to fetch projects, using mock data:', error);
    return MOCK_PROJECTS;
  }
}

/**
 * Fetch single project
 */
export async function fetchProject(projectId) {
  try {
    const url = `${API_BASE}/projects/${projectId}`;
    const headers = createDebugHeaders(projectId);
    console.log('[API] GET', url, { headers });
    
    const response = await fetch(url, { headers });
    if (response.ok) {
      const data = await response.json();
      console.log('[API] GET Response:', { projectId, title: data.project?.title || data.project?.topic });
      return data.project;
    }
    // Return mock project if not found
    return MOCK_PROJECTS.find(p => p.id === projectId) || MOCK_PROJECTS[0];
  } catch (error) {
    console.warn(`[API] Failed to fetch project ${projectId}, using mock data:`, error);
    return MOCK_PROJECTS.find(p => p.id === projectId) || MOCK_PROJECTS[0];
  }
}

/**
 * Create project from topic (주제추천 확정 시 사용 - 단일 진실 소스)
 */
export async function createProjectFromTopic(title, topicData = {}) {
  try {
    const url = `${API_BASE}/projects/from-topic`;
    const body = { 
      title: title.trim(),
      topicData 
    };
    const headers = createDebugHeaders();
    console.log('[API] POST /projects/from-topic', body, { headers });
    
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });
    
    if (response.ok) {
      const data = await response.json();
      console.log('[API] POST /projects/from-topic Response:', { 
        projectId: data.project?.id, 
        title: data.project?.title,
        folderName: data.project?.folderName
      });
      
      if (!data.ok || !data.project) {
        throw new Error(data.error || 'Create failed: invalid response');
      }
      
      return data.project;
    }
    
    // 에러 응답 처리
    let errorMessage = 'Failed to create project';
    try {
      const errorData = await response.json();
      errorMessage = errorData.error || errorMessage;
    } catch (e) {
      // JSON 파싱 실패 시 텍스트로 시도
      const text = await response.text().catch(() => '');
      errorMessage = text || `HTTP ${response.status}: ${response.statusText}`;
    }
    
    throw new Error(errorMessage);
  } catch (error) {
    console.error('[API] Create project from topic error:', error);
    // 네트워크 에러인 경우 더 명확한 메시지 제공
    if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
      throw new Error('백엔드 서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요.');
    }
    throw error;
  }
}

/**
 * Create new project (레거시 호환 - 사용 금지, createProjectFromTopic 사용 권장)
 * @deprecated Use createProjectFromTopic instead
 */
export async function createProject(name, type = 'general') {
  try {
    const url = `${API_BASE}/projects`;
    // 백엔드 API는 topic 필드를 기대함
    const body = { topic: name || '새로운 프로젝트', name: name || '새로운 프로젝트', type };
    const headers = createDebugHeaders();
    console.log('[API] POST', url, body, { headers });
    console.warn('[API] createProject is deprecated. Use createProjectFromTopic instead.');
    
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });
    
    if (response.ok) {
      const data = await response.json();
      console.log('[API] POST Response:', { projectId: data.projectId || data.project?.id, title: data.project?.title || data.project?.topic });
      return data.projectId || data.project?.id;
    }
    
    // 에러 응답 처리
    let errorMessage = 'Failed to create project';
    try {
      const errorData = await response.json();
      errorMessage = errorData.error || errorMessage;
    } catch (e) {
      // JSON 파싱 실패 시 텍스트로 시도
      const text = await response.text().catch(() => '');
      errorMessage = text || `HTTP ${response.status}: ${response.statusText}`;
    }
    
    throw new Error(errorMessage);
  } catch (error) {
    console.error('[API] Create project error:', error);
    // 네트워크 에러인 경우 더 명확한 메시지 제공
    if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
      throw new Error('백엔드 서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요.');
    }
    throw error;
  }
}

/**
 * Save script
 */
export async function saveScript(projectId, text) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}/scenes`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });
    if (response.ok) {
      return await response.json();
    }
    throw new Error('Failed to save script');
  } catch (error) {
    console.error('Save script error:', error);
    throw error;
  }
}

/**
 * Generate TTS
 */
export async function generateTTS(projectId, sceneId, voice, speed = 1.0) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}/generate/tts`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sceneId, voice, speed })
    });
    if (response.ok) {
      return await response.json();
    }
    throw new Error('Failed to generate TTS');
  } catch (error) {
    console.error('Generate TTS error:', error);
    throw error;
  }
}

/**
 * Generate subtitles
 */
export async function generateSubtitles(projectId) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}/generate/srt`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    if (response.ok) {
      return await response.json();
    }
    throw new Error('Failed to generate subtitles');
  } catch (error) {
    console.error('Generate subtitles error:', error);
    throw error;
  }
}

/**
 * Generate thumbnail
 */
export async function generateThumbnail(projectId, title, bgColor) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}/generate/thumbnail`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, bg_color: bgColor })
    });
    if (response.ok) {
      return await response.json();
    }
    throw new Error('Failed to generate thumbnail');
  } catch (error) {
    console.error('Generate thumbnail error:', error);
    throw error;
  }
}

/**
 * Upload BGM
 */
export async function uploadBGM(projectId, file) {
  try {
    const formData = new FormData();
    formData.append('file', file);
    const response = await fetch(`${API_BASE}/projects/${projectId}/upload/bgm`, {
      method: 'POST',
      body: formData
    });
    if (response.ok) {
      return await response.json();
    }
    throw new Error('Failed to upload BGM');
  } catch (error) {
    console.error('Upload BGM error:', error);
    throw error;
  }
}

/**
 * Start render
 */
export async function startRender(projectId) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}/render`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    if (response.ok) {
      return await response.json();
    }
    throw new Error('Failed to start render');
  } catch (error) {
    console.error('Start render error:', error);
    throw error;
  }
}

/**
 * Get file preview URL with cache buster
 */
export function getPreviewUrl(projectId, filePath) {
  return `${API_BASE}/projects/${projectId}/preview?path=${encodeURIComponent(filePath)}&v=${Date.now()}`;
}

/**
 * Get file download URL
 */
export function getDownloadUrl(projectId, filePath) {
  return `${API_BASE}/projects/${projectId}/download?path=${encodeURIComponent(filePath)}`;
}

/**
 * Update project (PATCH)
 */
export async function updateProject(projectId, data) {
  try {
    const url = `${API_BASE}/projects/${projectId}`;
    const headers = createDebugHeaders(projectId);
    console.log('[API] PATCH', url, data, { headers });
    
    const response = await fetch(url, {
      method: 'PATCH',
      headers,
      body: JSON.stringify(data)
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log('[API] PATCH Response:', { projectId, title: result.project?.title || result.project?.topic });
      return result;
    }
    
    // 에러 응답 처리
    let errorMessage = `Failed to update project: ${response.status}`;
    try {
      const errorData = await response.json();
      errorMessage = errorData.error || errorMessage;
    } catch (e) {
      // JSON 파싱 실패 시 텍스트로 시도
      const text = await response.text().catch(() => '');
      errorMessage = text || `HTTP ${response.status}: ${response.statusText}`;
    }
    
    throw new Error(errorMessage);
  } catch (error) {
    console.error('[API] Update project error:', error);
    // 네트워크 에러인 경우 더 명확한 메시지 제공
    if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
      throw new Error('백엔드 서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요.');
    }
    throw error;
  }
}

/**
 * 3. 대본생성부터 시작: 직접 작성/타겟팅 대본용 프로젝트 생성
 * - 최소 blueprint(직접 입력, 60초) 저장 후 대본생성 페이지로 이동용
 */
export async function createProjectForDirectScript(title = '직접 입력 대본') {
  const project = await createProjectFromTopic(title.trim() || '직접 입력 대본', {});
  if (!project || !project.id) throw new Error('프로젝트 생성 실패');
  const minimalBlueprint = { topic: '직접 입력', length: 60 };
  await updateProject(project.id, { blueprint: minimalBlueprint });
  return { ...project, blueprint: minimalBlueprint };
}

/**
 * Delete project (DELETE)
 */
export async function deleteProject(projectId) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}`, {
      method: 'DELETE'
    });
    if (response.ok) {
      return await response.json();
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `Failed to delete project: ${response.status}`);
  } catch (error) {
    console.error('Delete project error:', error);
    throw error;
  }
}

/**
 * Batch delete projects (POST /api/projects/batch-delete)
 */
export async function batchDeleteProjects(projectIds) {
  try {
    if (!Array.isArray(projectIds) || projectIds.length === 0) {
      throw new Error('projectIds must be a non-empty array');
    }
    
    console.log(`[API] 배치 삭제 요청: ${projectIds.length}개 프로젝트`);
    
    const response = await fetch(`${API_BASE}/projects/batch-delete`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ projectIds })
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log(`[API] 배치 삭제 성공:`, result);
      return result;
    }
    
    // 405 에러인 경우 개별 삭제로 자동 폴백 (에러를 던지지 않음)
    if (response.status === 405) {
      console.warn('[API] 배치 삭제 API가 서버에 없음 (405), 개별 삭제로 폴백');
      const results = [];
      for (const id of projectIds) {
        try {
          await deleteProject(id);
          results.push({ id, success: true });
        } catch (err) {
          console.error(`[API] 개별 삭제 실패: ${id}`, err);
          results.push({ id, success: false, error: err.message });
        }
      }
      return { 
        ok: true, 
        deleted: results.filter(r => r.success).map(r => r.id),
        failed: results.filter(r => !r.success).map(r => ({ id: r.id, reason: r.error })),
        successCount: results.filter(r => r.success).length,
        failureCount: results.filter(r => !r.success).length
      };
    }
    
    // 다른 에러인 경우에도 개별 삭제로 폴백 시도
    const errorData = await response.json().catch(() => ({}));
    console.warn(`[API] 배치 삭제 API 실패 (${response.status}), 개별 삭제로 폴백:`, errorData);
    
    const results = [];
    for (const id of projectIds) {
      try {
        await deleteProject(id);
        results.push({ id, success: true });
      } catch (err) {
        console.error(`[API] 개별 삭제 실패: ${id}`, err);
        results.push({ id, success: false, error: err.message });
      }
    }
    return { 
      ok: true, 
      deleted: results.filter(r => r.success).map(r => r.id),
      failed: results.filter(r => !r.success).map(r => ({ id: r.id, reason: r.error })),
      successCount: results.filter(r => r.success).length,
      failureCount: results.filter(r => !r.success).length
    };
  } catch (error) {
    console.error('[API] 배치 삭제 오류:', error);
    // 네트워크 에러 등 예외 상황에서도 개별 삭제로 폴백 시도
    console.warn('[API] 예외 발생, 개별 삭제로 폴백 시도');
    const results = [];
    for (const id of projectIds) {
      try {
        await deleteProject(id);
        results.push({ id, success: true });
      } catch (err) {
        console.error(`[API] 개별 삭제 실패: ${id}`, err);
        results.push({ id, success: false, error: err.message });
      }
    }
    return { 
      ok: true, 
      deleted: results.filter(r => r.success).map(r => r.id),
      failed: results.filter(r => !r.success).map(r => ({ id: r.id, reason: r.error })),
      successCount: results.filter(r => r.success).length,
      failureCount: results.filter(r => !r.success).length
    };
  }
}

/**
 * Toggle project pin status (즐겨찾기)
 */
export async function toggleProjectPin(projectId, isPinned) {
  const url = `${API_BASE}/projects/${projectId}`;
  const body = { pinned: isPinned, isPinned }; // 서버는 pinned / isPinned 둘 다 수용
  try {
    const response = await fetch(url, {
      method: 'PATCH',
      headers: createDebugHeaders(projectId),
      body: JSON.stringify(body)
    });
    const resBody = await response.json().catch(() => ({}));
    if (!response.ok) {
      throw new Error(resBody.error || `Failed to toggle pin: ${response.status}`);
    }
    return resBody;
  } catch (error) {
    console.error('Toggle project pin error:', error);
    throw error;
  }
}

/**
 * Touch project (최근 열람 시간 갱신)
 */
export async function touchProject(projectId) {
  try {
    const response = await fetch(`${API_BASE}/projects/${projectId}/touch`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    if (response.ok) {
      return await response.json();
    }
    // touch API가 없으면 PATCH로 lastOpenedAt 업데이트 시도
    const patchResponse = await fetch(`${API_BASE}/projects/${projectId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ lastOpenedAt: new Date().toISOString() })
    });
    if (patchResponse.ok) {
      return await patchResponse.json();
    }
    // 실패해도 에러를 던지지 않음 (선택적 기능)
    return { success: false };
  } catch (error) {
    console.warn('Touch project error (non-critical):', error);
    return { success: false };
  }
}

/**
 * Archive project (보관)
 */
export async function archiveProject(projectId) {
  const url = `${API_BASE}/projects/${projectId}`;
  const body = { archived: true, status: 'archived' }; // 서버는 둘 다 수용
  const headers = createDebugHeaders(projectId);
  try {
    const response = await fetch(url, {
      method: 'PATCH',
      headers,
      body: JSON.stringify(body)
    });
    const resBody = await response.json().catch(() => ({}));
    if (!response.ok) {
      const errMsg = resBody.error || `Failed to archive project: ${response.status}`;
      console.error('[API] Archive project failed:', resBody);
      throw new Error(errMsg);
    }
    return resBody && typeof resBody === 'object' ? resBody : { ok: true };
  } catch (error) {
    if (error instanceof Error && error.message.startsWith('Failed to archive')) throw error;
    console.error('[API] Archive project error:', error);
    throw error;
  }
}

/**
 * Unarchive project (보관 해제)
 */
export async function unarchiveProject(projectId) {
  const url = `${API_BASE}/projects/${projectId}`;
  const body = { archived: false, status: 'active' };
  const headers = createDebugHeaders(projectId);
  try {
    const response = await fetch(url, {
      method: 'PATCH',
      headers,
      body: JSON.stringify(body)
    });
    const resBody = await response.json().catch(() => ({}));
    if (!response.ok) {
      console.error('[API] Unarchive project failed:', resBody);
      throw new Error(resBody.error || `Failed to unarchive project: ${response.status}`);
    }
    return resBody && typeof resBody === 'object' ? resBody : { ok: true };
  } catch (error) {
    if (error instanceof Error && error.message.startsWith('Failed to unarchive')) throw error;
    console.error('[API] Unarchive project error:', error);
    throw error;
  }
}

/**
 * Batch unarchive projects (보관 해제)
 */
export async function batchUnarchiveProjects(projectIds) {
  try {
    if (!Array.isArray(projectIds) || projectIds.length === 0) {
      return { ok: false, error: 'projectIds must be a non-empty array' };
    }
    
    console.log(`[API] 배치 보관 해제 요청: ${projectIds.length}개 프로젝트`);
    
    const url = `${API_BASE}/projects/batch-unarchive`;
    const body = { projectIds };
    const headers = createDebugHeaders();
    console.log('[API] POST', url, body, { headers });
    
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });
    
    if (response.ok) {
      try {
        const result = await response.json();
        console.log(`[API] 배치 보관 해제 성공:`, result);
        return result;
      } catch (parseError) {
        console.error('[API] 배치 보관 해제 응답 JSON 파싱 실패:', parseError);
        return await fallbackToIndividualUnarchive(projectIds);
      }
    }
    
    // 서버 에러인 경우 JSON 또는 텍스트로 파싱 시도
    let errorData = {};
    try {
      const contentType = response.headers.get('content-type') || '';
      if (contentType.includes('application/json')) {
        errorData = await response.json();
      } else {
        const text = await response.text();
        errorData = { error: text.substring(0, 200) || `HTTP ${response.status}` };
        console.error('[API] 서버가 JSON 대신 다른 형식을 반환:', contentType);
      }
    } catch (parseError) {
      errorData = { error: `HTTP ${response.status}: Failed to parse error response` };
    }
    
    console.warn(`[API] 배치 보관 해제 API 실패 (${response.status}), 개별 보관 해제로 폴백:`, errorData);
    
    // 개별 보관 해제로 폴백
    return await fallbackToIndividualUnarchive(projectIds);
    
  } catch (error) {
    console.error('[API] 배치 보관 해제 예외 발생:', error);
    return await fallbackToIndividualUnarchive(projectIds);
  }
  
  // 개별 보관 해제로 폴백하는 헬퍼 함수
  async function fallbackToIndividualUnarchive(projectIds) {
    const results = [];
    for (const id of projectIds) {
      const unarchiveResult = await unarchiveProject(id);
      if (unarchiveResult.ok) {
        results.push({ id, success: true });
      } else {
        results.push({ id, success: false, error: unarchiveResult.error || 'Unarchive failed' });
      }
    }
    return { 
      ok: true, 
      updated: results.filter(r => r.success).map(r => r.id),
      failed: results.filter(r => !r.success).map(r => ({ id: r.id, reason: r.error })),
      successCount: results.filter(r => r.success).length,
      failureCount: results.filter(r => !r.success).length
    };
  }
}

/**
 * Batch archive projects
 */
export async function batchArchiveProjects(projectIds) {
  try {
    if (!Array.isArray(projectIds) || projectIds.length === 0) {
      // 절대 throw하지 않고 {ok: false} 반환
      return { ok: false, error: 'projectIds must be a non-empty array' };
    }
    
    console.log(`[API] 배치 보관 요청: ${projectIds.length}개 프로젝트`);
    
    const url = `${API_BASE}/projects/batch-archive`;
    const body = { projectIds, status: 'archived' };
    const headers = createDebugHeaders();
    console.log('[API] POST', url, body, { headers });
    
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });
    
    if (response.ok) {
      try {
        const result = await response.json();
        console.log(`[API] 배치 보관 성공:`, result);
        return result;
      } catch (parseError) {
        console.error('[API] 배치 보관 응답 JSON 파싱 실패:', parseError);
        // 파싱 실패해도 개별 보관으로 폴백 (절대 throw하지 않음)
        return await fallbackToIndividualArchive(projectIds);
      }
    }
    
    // 서버 에러인 경우 JSON 또는 텍스트로 파싱 시도
    let errorData = {};
    try {
      const contentType = response.headers.get('content-type') || '';
      if (contentType.includes('application/json')) {
        errorData = await response.json();
      } else {
        const text = await response.text();
        errorData = { error: text.substring(0, 200) || `HTTP ${response.status}` };
        console.error('[API] 서버가 JSON 대신 다른 형식을 반환:', contentType);
      }
    } catch (parseError) {
      errorData = { error: `HTTP ${response.status}: Failed to parse error response` };
    }
    
    console.warn(`[API] 배치 보관 API 실패 (${response.status}), 개별 보관으로 폴백:`, errorData);
    
    // 개별 보관으로 폴백 (절대 throw하지 않음)
    return await fallbackToIndividualArchive(projectIds);
    
  } catch (error) {
    // 네트워크 에러 등 예외 상황에서도 개별 보관으로 폴백 (절대 throw하지 않음)
    console.error('[API] 배치 보관 예외 발생:', error);
    return await fallbackToIndividualArchive(projectIds);
  }
  
  // 개별 보관으로 폴백하는 헬퍼 함수
  async function fallbackToIndividualArchive(projectIds) {
    const results = [];
    for (const id of projectIds) {
      const archiveResult = await archiveProject(id);
      if (archiveResult.ok) {
        results.push({ id, success: true });
      } else {
        results.push({ id, success: false, error: archiveResult.error || 'Archive failed' });
      }
    }
    return { 
      ok: true, 
      updated: results.filter(r => r.success).map(r => r.id),
      failed: results.filter(r => !r.success).map(r => ({ id: r.id, reason: r.error })),
      successCount: results.filter(r => r.success).length,
      failureCount: results.filter(r => !r.success).length
    };
  }
}

/**
 * Fetch project statistics (KPI)
 */
export async function fetchProjectStats() {
  try {
    const response = await fetch(`${API_BASE}/projects/stats`);
    if (response.ok) {
      const data = await response.json();
      // 응답 형식: { ok: true, totalProjects, activeProjects, ... }
      if (data.ok && data.totalProjects !== undefined) {
        return {
          totalProjects: data.totalProjects,
          activeProjects: data.activeProjects,
          archivedProjects: data.archivedProjects,
          completedProjects: data.completedProjects,
          avgScenesCount: data.avgScenesCount || 0,
          avgDurationSeconds: data.avgDurationSeconds || null
        };
      }
      return data;
    }
    // API가 없으면 null 반환 (프론트에서 계산)
    return null;
  } catch (error) {
    console.warn('Failed to fetch project stats, will calculate on frontend:', error);
    return null;
  }
}
